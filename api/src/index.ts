import express, { Request, Response } from "express";
import cors from "cors";
import { prisma } from "./db.js";
import { buildPlan, nextMonday, Task as SchedTask } from "./scheduler.js";
import { WEEK_COUNT, PEOPLE_WEEKLY, PEOPLE_BIWEEKLY, TASKS } from "./config.js";
import { createEvents, EventAttributes } from "ics";

const app = express();
app.use(cors());
app.use(express.json());

// Health
app.get("/", (_req: Request, res: Response) => res.send("Ämtli API OK"));

/**
 * Generate a DRAFT plan in DB with assignments (has IDs)
 */
app.post("/api/plan/generate", async (_req: Request, res: Response) => {
  const start = nextMonday();

  // Ensure tasks exist (including offsetWeeks)
  for (const t of TASKS) {
    await prisma.task.upsert({
      where: { slug: t.slug },
      update: { title: t.title, cadence: t.cadence, offsetWeeks: t.offsetWeeks ?? 0 },
      create: { slug: t.slug, title: t.title, cadence: t.cadence, offsetWeeks: t.offsetWeeks ?? 0 },
    });
  }

  // Ensure people exist (both pools)
  for (const name of [...PEOPLE_WEEKLY, ...PEOPLE_BIWEEKLY]) {
    await prisma.person.upsert({ where: { name }, update: {}, create: { name } });
  }

  // Fetch tasks from DB and map to scheduler type (typed, no `any`)
  const dbTasksRaw = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const dbTasks: SchedTask[] = dbTasksRaw.map(t => ({
    id: t.id,
    slug: t.slug,
    title: t.title,
    cadence: (t.cadence === "biweekly" ? "biweekly" : "weekly"),
    offsetWeeks: (t as any).offsetWeeks ?? 0, // Prisma type might not include it in your client; cast defensively
  }));

  // Temporary generator people (IDs local to the generator, mapped by name later)
  const weeklyPeople   = PEOPLE_WEEKLY.map((name, i) => ({ id: i + 1,    name, shame: 0, activeWeekly: true,  activeBiweekly: false }));
  const biweeklyPeople = PEOPLE_BIWEEKLY.map((name, i) => ({ id: i + 101, name, shame: 0, activeWeekly: false, activeBiweekly: true }));

  const slots = buildPlan({
    startsOn: start,
    weeks: WEEK_COUNT,
    peopleWeekly: weeklyPeople,
    peopleBiweekly: biweeklyPeople,
    tasks: dbTasks,
  });

  const plan = await prisma.plan.create({ data: { startsOn: start, weeks: WEEK_COUNT, status: "draft" } });

  // Map generator person names to DB person IDs
  const peopleDb = await prisma.person.findMany();
  const nameToId = new Map<string, number>(peopleDb.map(p => [p.name, p.id]));
  function mapPerson(genId: number | null): number | null {
    if (genId == null) return null;
    const p = [...weeklyPeople, ...biweeklyPeople].find(x => x.id === genId);
    return p ? (nameToId.get(p.name) ?? null) : null;
  }

  for (const s of slots) {
    await prisma.assignment.create({
      data: {
        planId: plan.id,
        taskId: s.taskId,
        weekIndex: s.weekIndex,
        personId: mapPerson(s.personId),
        autoGenerated: true,
      },
    });
  }

  res.json({ planId: plan.id });
});

/**
 * Publish latest draft by id
 */
app.post("/api/plan/:id/publish", async (req: Request, res: Response) => {
  const { id } = req.params;
  await prisma.plan.update({ where: { id }, data: { status: "published" } });
  res.json({ ok: true });
});

/**
 * Public current plan (PUBLISHED only)
 */
app.get("/api/plan/current", async (_req, res) => {
  const plan = await prisma.plan.findFirst({
    where: { status: "published" },
    orderBy: { startsOn: "desc" },
  });

  if (!plan) {
    return res.json({ empty: true, startsOn: null, tasks: [], slots: [], people: [] });
  }

  const tasks = await prisma.task.findMany();
  const slots = await prisma.assignment.findMany({
    where: { planId: plan.id },
    orderBy: [{ weekIndex: "asc" }, { taskId: "asc" }],
  });
  const people = await prisma.person.findMany({ orderBy: { name: "asc" } });

  res.json({ empty: false, startsOn: plan.startsOn, weeks: plan.weeks, tasks, slots, people });
});

/**
 * Admin plan (DRAFT if exists, else PUBLISHED) including assignment IDs
 */
app.get("/api/admin/plan", async (_req: Request, res: Response) => {
  const draft = await prisma.plan.findFirst({ where: { status: "draft" }, orderBy: { startsOn: "desc" } });
  const plan  = draft ?? await prisma.plan.findFirst({ where: { status: "published" }, orderBy: { startsOn: "desc" } });

  if (!plan) {
    return res.json({ empty: true, plan: null, tasks: [], assignments: [], people: [] });
  }

  const tasks        = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const assignments  = await prisma.assignment.findMany({
    where: { planId: plan.id },
    orderBy: [{ taskId: "asc" }, { weekIndex: "asc" }],
  });
  const people       = await prisma.person.findMany({ orderBy: { name: "asc" } });

  res.json({ plan, tasks, assignments, people });
});
/**
 * Debug Route: List all plans
 */
app.get('/__routes', (_req, res) => {
  // @ts-ignore
  const routes = app._router.stack
    .filter((r: any) => r.route && r.route.path)
    .map((r: any) => ({ method: Object.keys(r.route.methods)[0].toUpperCase(), path: r.route.path }));
  res.json(routes);
});


/**
 * Update one assignment (drag & drop)
 */
app.patch("/api/assignment/:id", async (req: Request, res: Response) => {
  const id = Number(req.params.id);
  const { personId } = req.body as { personId: number | null };
  await prisma.assignment.update({ where: { id }, data: { personId } });
  res.json({ ok: true });
});

/**
 * People list for admin sidebar
 */
app.get("/api/people", async (_req: Request, res: Response) => {
  const people = await prisma.person.findMany({ orderBy: { name: "asc" } });
  res.json(people);
});

/**
 * ICS for a given person from the latest PUBLISHED plan
 */
app.get("/api/ics/:personId", async (req: Request, res: Response) => {
  const personId = Number(req.params.personId);
  const plan = await prisma.plan.findFirst({ where: { status: "published" }, orderBy: { startsOn: "desc" } });
  if (!plan) return res.status(404).send("No plan");

  const tasks = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const slots = await prisma.assignment.findMany({ where: { planId: plan.id, personId } });

  const startTime = process.env.ICS_START_TIME || "18:00";
  const [hh, mm] = startTime.split(":").map(x => parseInt(x, 10));

  const events: EventAttributes[] = slots.map(s => {
    const monday = new Date(plan.startsOn);
    monday.setDate(monday.getDate() + 7 * s.weekIndex);
    const task = tasks.find(t => t.id === s.taskId)!;
    return {
      uid: `assign-${s.taskId}-${s.weekIndex}-${personId}@aemtli`,
      title: `Ämtli – ${task.title}`,
      start: [monday.getFullYear(), monday.getMonth() + 1, monday.getDate(), hh, mm || 0] as [number, number, number, number, number],
      end:   [monday.getFullYear(), monday.getMonth() + 1, monday.getDate(), (hh + 1) % 24, mm || 0] as [number, number, number, number, number],
      description: `Woche ${s.weekIndex + 1} von 16`,
    };
  });

  const { error, value } = createEvents(events);
  if (error) return res.status(500).send(String(error));
  res.setHeader("Content-Type", "text/calendar; charset=utf-8");
  res.setHeader("Content-Disposition", `attachment; filename="user-${personId}-aemtli.ics"`);
  res.send(value);
});

// Start server
const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`API listening on :${port}`);
});
