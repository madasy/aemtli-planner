import express, { Request, Response } from "express";
import cors from "cors";
import { prisma } from "./db.js";
import { buildPlan, Task as SchedTask, Person as SchedPerson } from "./scheduler.js";
import { WEEK_COUNT, TASKS } from "./config.js";
import { createEvents, EventAttributes } from "ics";
import { renderPlanPdf } from "./pdf.js";

const app = express();
app.use(cors());
app.use(express.json());

// Health
app.get("/", (_req: Request, res: Response) => res.send("Ämtli API OK"));

/**
 * Generate a DRAFT plan in DB with assignments (has IDs)
 */
app.post("/api/plan/generate", async (req: Request, res: Response) => {
  // ---- 1) start date (snap to Monday) ----
  function nextOrSameMonday(from = new Date()) {
    const d = new Date(from);
    const day = d.getDay(); // 0=Sun, 1=Mon ... 6=Sat
    const add = (8 - day) % 7; // Mon→0, Tue→6, Sun→1
    d.setDate(d.getDate() + add);
    d.setHours(0, 0, 0, 0);
    return d;
  }

  let start: Date;
  if (req.body?.startDate) {
    const parsed = new Date(`${req.body.startDate}T00:00:00`);
    if (isNaN(parsed.getTime())) {
      return res.status(400).json({ error: "Invalid startDate (use YYYY-MM-DD)" });
    }
    start = parsed.getDay() === 1 ? parsed : nextOrSameMonday(parsed);
  } else {
    start = nextOrSameMonday();
  }

  // ---- 2) ensure tasks exist/updated (incl. offsetWeeks) ----
  for (const t of TASKS) {
    await prisma.task.upsert({
      where: { slug: t.slug },
      update: { title: t.title, cadence: t.cadence, offsetWeeks: t.offsetWeeks ?? 0 },
      create: { slug: t.slug, title: t.title, cadence: t.cadence, offsetWeeks: t.offsetWeeks ?? 0 },
    });
  }

  // ---- 3) remove old DRAFT(s) and their assignments ----
  const drafts = await prisma.plan.findMany({ where: { status: "draft" }, select: { id: true } });
  if (drafts.length) {
    const draftIds = drafts.map(d => d.id);
    await prisma.assignment.deleteMany({ where: { planId: { in: draftIds } } });
    await prisma.plan.deleteMany({ where: { id: { in: draftIds } } });
  }

  // ---- 4) fetch tasks for scheduler ----
  const dbTasksRaw = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const dbTasks: SchedTask[] = dbTasksRaw.map(t => ({
    id: t.id,
    slug: t.slug,
    title: t.title,
    cadence: t.cadence === "biweekly" ? "biweekly" : "weekly",
    offsetWeeks: (t as any).offsetWeeks ?? 0,
  }));

  // ---- 5) fetch people and build shuffled pools (flags respected) ----
  const peopleDb = await prisma.person.findMany({
    orderBy: { name: "asc" },
    select: {
      id: true,
      name: true,
      activeWeekly: true,
      activeBiweekly: true,
      exceptions: true,
      shameCount: true,
      unavailable: true,
    },
  });

  const shuffle = <T,>(arr: T[]) => [...arr].sort(() => Math.random() - 0.5);

  const weeklyPeople: SchedPerson[] = shuffle(
    peopleDb
      .filter(p => p.activeWeekly)
      .map(p => ({
        id: p.id,
        name: p.name,
        shame: p.shameCount ?? 0,
        activeWeekly: p.activeWeekly,
        activeBiweekly: p.activeBiweekly,
        // @ts-ignore
        exceptions: p.exceptions ?? [],
        // @ts-ignore
        unavailable: p.unavailable ?? [],
      }))
  );

  const biweeklyPeople: SchedPerson[] = shuffle(
    peopleDb
      .filter(p => p.activeBiweekly)
      .map(p => ({
        id: p.id,
        name: p.name,
        shame: p.shameCount ?? 0,
        activeWeekly: p.activeWeekly,
        activeBiweekly: p.activeBiweekly,
        // @ts-ignore
        exceptions: p.exceptions ?? [],
        // @ts-ignore
        unavailable: p.unavailable ?? [],
      }))
  );

  // ---- 6) build slots with scheduler ----
  const slots = buildPlan({
    startsOn: start,
    weeks: WEEK_COUNT,
    peopleWeekly: weeklyPeople,
    peopleBiweekly: biweeklyPeople,
    tasks: dbTasks,
  });

  // avoid duplicate (taskId, weekIndex) within the batch
  const seen = new Set<string>();
  const deduped = slots.filter(s => {
    const k = `${s.taskId}:${s.weekIndex}`;
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });

  // ---- 7) create plan + assignments (bulk) ----
  const plan = await prisma.plan.create({
    data: { startsOn: start, weeks: WEEK_COUNT, status: "draft" },
  });

  if (deduped.length) {
    await prisma.assignment.createMany({
      data: deduped.map(s => ({
        planId: plan.id,
        taskId: s.taskId,
        weekIndex: s.weekIndex,
        personId: s.personId ?? null,
        autoGenerated: true,
      })),
      skipDuplicates: true,
    });
  }

  res.json({ planId: plan.id });
});

/**
 * Generate PDF of the current plan
 */

app.get("/api/plan/pdf", async (_req, res) => {
  try {
    await renderPlanPdf(res);
  } catch (e:any) {
    console.error(e);
    res.status(500).send("PDF failed");
  }
});

/**
 * Publish latest draft by id
 */
// Publish latest draft by id (archive all other published)
app.post("/api/plan/:id/publish", async (req: Request, res: Response) => {
  const { id } = req.params;

  const [_, plan] = await prisma.$transaction([
    prisma.plan.updateMany({
      where: { status: "published", NOT: { id } },
      data: { status: "archived" }, // make sure your Plan.status is a string; 'archived' is fine
    }),
    prisma.plan.update({
      where: { id },
      data: { status: "published" },
    }),
  ]);

  res.setHeader("Cache-Control", "no-store");
  res.json({ ok: true, plan });
});

// Clone a published plan into a new draft
app.post("/api/plan/:id/clone-to-draft", async (req, res) => {
  const { id } = req.params;

  const src = await prisma.plan.findUnique({ where: { id } });
  if (!src || src.status !== "published") {
    return res.status(400).json({ error: "Only a published plan can be cloned to a draft." });
  }

  const draft = await prisma.plan.create({
    data: { startsOn: src.startsOn, weeks: src.weeks, status: "draft" },
  });

  const assigns = await prisma.assignment.findMany({ where: { planId: src.id } });
  if (assigns.length) {
    await prisma.assignment.createMany({
      data: assigns.map(a => ({
        planId: draft.id,
        taskId: a.taskId,
        weekIndex: a.weekIndex,
        personId: a.personId,
        autoGenerated: false,
      })),
    });
  }

  res.json({ ok: true, plan: draft });
});


/**
 * Public current plan (PUBLISHED only)
 */
app.get("/api/plan/current", async (_req, res) => {
  const plan = await prisma.plan.findFirst({
    where: { status: "published" },
    orderBy: { startsOn: "desc" },
  });

  if (!plan) {
    res.setHeader("Cache-Control", "no-store");
    return res.json({ empty: true, startsOn: null, tasks: [], slots: [], people: [], duties: [] });
  }

  const tasks = await prisma.task.findMany();
  const slots = await prisma.assignment.findMany({
    where: { planId: plan.id },
    orderBy: [{ weekIndex: "asc" }, { taskId: "asc" }],
  });
  const people = await prisma.person.findMany({ orderBy: { name: "asc" } });
  const duties = await prisma.duty.findMany({ orderBy: [{ kind: 'asc' }, { order: 'asc' }] }); // <-- ADDED

  res.setHeader("Cache-Control", "no-store");
  res.json({ empty: false, startsOn: plan.startsOn, weeks: plan.weeks, tasks, slots, people, duties }); // <-- ADDED duties to response
});

/**
 * Admin plan (DRAFT if exists, else PUBLISHED) including assignment IDs
 */
app.get("/api/admin/plan", async (_req: Request, res: Response) => {
  const draft = await prisma.plan.findFirst({ where: { status: "draft" }, orderBy: { startsOn: "desc" } });
  const plan  = draft ?? await prisma.plan.findFirst({ where: { status: "published" }, orderBy: { startsOn: "desc" } });

  if (!plan) {
    res.setHeader("Cache-Control", "no-store");
    return res.json({ empty: true, plan: null, tasks: [], assignments: [], people: [] });
  }

  const tasks        = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const assignments  = await prisma.assignment.findMany({
    where: { planId: plan.id },
    orderBy: [{ taskId: "asc" }, { weekIndex: "asc" }],
  });
  const people       = await prisma.person.findMany({ orderBy: { name: "asc" } });

  res.setHeader("Cache-Control", "no-store");
  res.json({ plan, tasks, assignments, people });
});

/**
 * Debug Route: List all routes
 */
app.get("/__routes", (_req, res) => {
  // @ts-ignore
  const routes = app._router.stack
    .filter((r: any) => r.route && r.route.path)
    .map((r: any) => ({ method: Object.keys(r.route.methods)[0].toUpperCase(), path: r.route.path }));
  res.json(routes);
});

/**
 * Update one assignment (drag & drop)
 */
app.patch("/api/assignment/:id", async (req: Request, res: Response) => {
  const id = Number(req.params.id);
  const { personId } = req.body as { personId: number | null };
  await prisma.assignment.update({ where: { id }, data: { personId } });
  res.json({ ok: true });
});

/**
 * People CRUD + flags + exceptions + shameCount
 */
app.get("/api/people", async (_req, res) => {
  const people = await prisma.person.findMany({
    orderBy: { name: "asc" },
    select: { id: true, name: true, activeWeekly: true, activeBiweekly: true, exceptions: true, shameCount: true },
  });
  res.json(people);
});

app.post("/api/people", async (req, res) => {
  const { name } = req.body ?? {};
  if (!name || typeof name !== "string") return res.status(400).json({ error: "name required" });
  const person = await prisma.person.create({
    data: { name, activeWeekly: false, activeBiweekly: false, exceptions: [] },
    select: { id: true, name: true, activeWeekly: true, activeBiweekly: true, exceptions: true, shameCount: true },
  });
  res.status(201).json(person);
});

app.patch("/api/people/:id", async (req, res) => {
  const id = Number(req.params.id);
  const { name, activeWeekly, activeBiweekly, shameCount } = req.body ?? {};
  const person = await prisma.person.update({
    where: { id },
    data: {
      ...(name !== undefined ? { name } : {}),
      ...(activeWeekly !== undefined ? { activeWeekly } : {}),
      ...(activeBiweekly !== undefined ? { activeBiweekly } : {}),
      ...(shameCount !== undefined ? { shameCount } : {}),
    },
    select: { id: true, name: true, activeWeekly: true, activeBiweekly: true, exceptions: true, shameCount: true },
  });
  res.json(person);
});

app.patch("/api/people/:id/exceptions", async (req, res) => {
  const id = Number(req.params.id);
  const { exceptions } = req.body as { exceptions: string[] };
  const person = await prisma.person.update({
    where: { id },
    data: { exceptions: exceptions ?? [] },
    select: { id: true, name: true, activeWeekly: true, activeBiweekly: true, exceptions: true, shameCount: true },
  });
  res.json(person);
});

app.delete("/api/people/:id", async (req, res) => {
  const id = Number(req.params.id);
  await prisma.assignment.updateMany({ where: { personId: id }, data: { personId: null } });
  await prisma.person.delete({ where: { id } });
  res.json({ ok: true });
});

// get unavailable
app.get("/api/people/:id/unavailable", async (req, res) => {
  const id = Number(req.params.id);
  const p = await prisma.person.findUnique({ where: { id }, select: { unavailable: true } });
  res.json(p?.unavailable ?? []);
});

// replace unavailable
app.patch("/api/people/:id/unavailable", async (req, res) => {
  const id = Number(req.params.id);
  const { unavailable } = req.body as { unavailable: Array<{from:string; to:string}> };
  const p = await prisma.person.update({ where: { id }, data: { unavailable } });
  res.json({ ok:true, unavailable: p.unavailable });
});

/**
 * ICS for a given person from the latest PUBLISHED plan
 */
app.get("/api/ics/:personId", async (req: Request, res: Response) => {
  const personId = Number(req.params.personId);

  // 1. Fetch person details to get their name for the filename
  const person = await prisma.person.findUnique({ where: { id: personId }, select: { name: true } });
  if (!person) {
    return res.status(404).send("Person not found");
  }

  const plan = await prisma.plan.findFirst({ where: { status: "published" }, orderBy: { startsOn: "desc" } });
  if (!plan) {
    return res.status(404).send("No plan");
  }

  const tasks = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const slots = await prisma.assignment.findMany({ where: { planId: plan.id, personId } });

  // startTime (hh, mm) is no longer needed for full-day events, removed its usage below.
  // const startTime = process.env.ICS_START_TIME || "18:00";
  // const [hh, mm] = startTime.split(":").map(x => parseInt(x, 10));

  const events: EventAttributes[] = slots.map(s => {
    const monday = new Date(plan.startsOn);
    monday.setDate(monday.getDate() + 7 * s.weekIndex);

    // 2. Calculate end date for a full-day event:
    // For a task covering Monday to Sunday of a given week,
    // the ICS DTEND for an all-day event should be the *next* Monday.
    const nextMonday = new Date(monday);
    nextMonday.setDate(monday.getDate() + 7); // Add 7 days to get to the next Monday

    const task = tasks.find(t => t.id === s.taskId)!;
    
    return {
      uid: `assign-${s.taskId}-${s.weekIndex}-${personId}@aemtli`,
      title: `Ämtli – ${task.title}`,
      // Full-day event: only year, month, and day components for start and end
      start: [monday.getFullYear(), monday.getMonth() + 1, monday.getDate()],
      end:   [nextMonday.getFullYear(), nextMonday.getMonth() + 1, nextMonday.getDate()],
      description: `Woche ${s.weekIndex + 1} von 16`,
      // 3. Mark as "Free" using transp property
      transp: 'TRANSPARENT', // Indicates free time
      // Optional: Add a calendar name for better organization in some calendar apps
      calName: 'Ämtliplan - Hacienda Jose',
    };
  });

  const { error, value } = createEvents(events);
  if (error) {
    console.error("Error creating ICS events:", error);
    return res.status(500).send(String(error));
  }

  // Generate new filename: personId-personname-aemtli.ics
  // Sanitize the person's name for safe use in a filename
  const personNameCleaned = person.name.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '-').toLowerCase();
  const filename = `${personId}-${personNameCleaned}-aemtli.ics`;

  res.setHeader("Content-Type", "text/calendar; charset=utf-8");
  res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
  res.send(value);
});

/* Duties CRUD (admin-managed fixed/honor lists) */
app.get('/api/duties', async (_req, res) => {
  const rows = await prisma.duty.findMany({ orderBy: [{ kind: 'asc' }, { order: 'asc' }] });
  res.json(rows);
});
app.post('/api/duties', async (req, res) => {
  const { kind, label, assignees = '', order = 0 } = req.body ?? {};
  if (!kind || !label) return res.status(400).json({ error: 'kind and label required' });
  const row = await prisma.duty.create({ data: { kind, label, assignees, order } });
  res.status(201).json(row);
});
app.patch('/api/duties/:id', async (req, res) => {
  const id = Number(req.params.id);
  const { kind, label, assignees, order } = req.body ?? {};
  const row = await prisma.duty.update({
    where: { id },
    data: {
      ...(kind != null ? { kind } : {}),
      ...(label != null ? { label } : {}),
      ...(assignees != null ? { assignees } : {}),
      ...(order != null ? { order } : {}),
    },
  });
  res.json(row);
});
app.delete('/api/duties/:id', async (req, res) => {
  const id = Number(req.params.id);
  await prisma.duty.delete({ where: { id } });
  res.json({ ok: true });
});

// Start server
const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`API listening on :${port}`);
});