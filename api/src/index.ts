app.post("/api/plan/generate", async (req: Request, res: Response) => {
  // 1) start date from request body or default to nextMonday
  let start: Date;
  if (req.body?.startDate) {
    const parsed = new Date(req.body.startDate);
    if (isNaN(parsed.getTime())) {
      return res.status(400).json({ error: "Invalid startDate" });
    }
    start = parsed;
  } else {
    start = nextMonday();
  }

  // 2) ensure tasks exist/updated (incl. offsetWeeks)
  for (const t of TASKS) {
    await prisma.task.upsert({
      where: { slug: t.slug },
      update: { title: t.title, cadence: t.cadence, offsetWeeks: t.offsetWeeks ?? 0 },
      create: { slug: t.slug, title: t.title, cadence: t.cadence, offsetWeeks: t.offsetWeeks ?? 0 },
    });
  }

  // 3) remove old DRAFT(s) and their assignments
  const drafts = await prisma.plan.findMany({ where: { status: "draft" }, select: { id: true } });
  if (drafts.length) {
    const draftIds = drafts.map(d => d.id);
    await prisma.assignment.deleteMany({ where: { planId: { in: draftIds } } });
    await prisma.plan.deleteMany({ where: { id: { in: draftIds } } });
  }

  // 4) fetch tasks for scheduler
  const dbTasksRaw = await prisma.task.findMany({ orderBy: { id: "asc" } });
  const dbTasks: SchedTask[] = dbTasksRaw.map(t => ({
    id: t.id,
    slug: t.slug,
    title: t.title,
    cadence: t.cadence === "biweekly" ? "biweekly" : "weekly",
    offsetWeeks: (t as any).offsetWeeks ?? 0,
  }));

  // 5) fetch people and build pools
  const peopleDb = await prisma.person.findMany({
    orderBy: { name: "asc" },
    select: { id: true, name: true, activeWeekly: true, activeBiweekly: true, exceptions: true },
  });

  function shuffle<T>(arr: T[]): T[] {
    return [...arr].sort(() => Math.random() - 0.5);
  }

  const weeklyPeople: SchedPerson[] = shuffle(
    peopleDb
      .filter(p => p.activeWeekly)
      .map(p => ({
        id: p.id,
        name: p.name,
        shame: 0,
        activeWeekly: p.activeWeekly,
        activeBiweekly: p.activeBiweekly,
        // @ts-ignore
        exceptions: p.exceptions ?? [],
      }))
  );

  const biweeklyPeople: SchedPerson[] = shuffle(
    peopleDb
      .filter(p => p.activeBiweekly)
      .map(p => ({
        id: p.id,
        name: p.name,
        shame: 0,
        activeWeekly: p.activeWeekly,
        activeBiweekly: p.activeBiweekly,
        // @ts-ignore
        exceptions: p.exceptions ?? [],
      }))
  );

  // 6) build slots
  const slots = buildPlan({
    startsOn: start,
    weeks: WEEK_COUNT,
    peopleWeekly: weeklyPeople,
    peopleBiweekly: biweeklyPeople,
    tasks: dbTasks,
  });

  // 7) create plan + assignments
  const plan = await prisma.plan.create({
    data: { startsOn: start, weeks: WEEK_COUNT, status: "draft" },
  });

  for (const s of slots) {
    await prisma.assignment.create({
      data: {
        planId: plan.id,
        taskId: s.taskId,
        weekIndex: s.weekIndex,
        personId: s.personId ?? null,
        autoGenerated: true,
      },
    });
  }

  res.json({ planId: plan.id });
});
